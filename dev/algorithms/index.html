<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · TwoStageSpanningTree.jl</title><meta name="title" content="Algorithms · TwoStageSpanningTree.jl"/><meta property="og:title" content="Algorithms · TwoStageSpanningTree.jl"/><meta property="twitter:title" content="Algorithms · TwoStageSpanningTree.jl"/><meta name="description" content="Documentation for TwoStageSpanningTree.jl."/><meta property="og:description" content="Documentation for TwoStageSpanningTree.jl."/><meta property="twitter:description" content="Documentation for TwoStageSpanningTree.jl."/><meta property="og:url" content="https://BatyLeo.github.io/TwoStageSpanningTree.jl/algorithms/"/><meta property="twitter:url" content="https://BatyLeo.github.io/TwoStageSpanningTree.jl/algorithms/"/><link rel="canonical" href="https://BatyLeo.github.io/TwoStageSpanningTree.jl/algorithms/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TwoStageSpanningTree.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">TwoStageSpanningTree</a></li><li><a class="tocitem" href="../problem_statement/">Problem statement</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#2.-Column-generation"><span>2. Column generation</span></a></li><li><a class="tocitem" href="#3.-Benders-decomposition"><span>3. Benders decomposition</span></a></li><li><a class="tocitem" href="#4.-Lagrangian-relaxation"><span>4. Lagrangian relaxation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BatyLeo/TwoStageSpanningTree.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/BatyLeo/TwoStageSpanningTree.jl/blob/main/docs/src/literate/algorithms.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><p>This package implements four different algorithms to solve the two-satge minimum wright spanning tree problem.</p><p>Random instances for the problem can be generated as follows:</p><pre><code class="language-julia hljs">using TwoStageSpanningTree, BenchmarkTools
n = 5
m = 4
instance = TwoStageSpanningTreeInstance(; n, m, nb_scenarios=20, seed=0);

# 1. Cut generation algorithm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Graphs.SimpleGraphs.SimpleEdge{Int64}[Edge 1 =&gt; 2, Edge 1 =&gt; 6, Edge 2 =&gt; 3, Edge 2 =&gt; 7, Edge 3 =&gt; 4, Edge 3 =&gt; 8, Edge 4 =&gt; 5, Edge 4 =&gt; 9, Edge 5 =&gt; 10, Edge 6 =&gt; 7, Edge 6 =&gt; 11, Edge 7 =&gt; 8, Edge 7 =&gt; 12, Edge 8 =&gt; 9, Edge 8 =&gt; 13, Edge 9 =&gt; 10, Edge 9 =&gt; 14, Edge 10 =&gt; 15, Edge 11 =&gt; 12, Edge 11 =&gt; 16, Edge 12 =&gt; 13, Edge 12 =&gt; 17, Edge 13 =&gt; 14, Edge 13 =&gt; 18, Edge 14 =&gt; 15, Edge 14 =&gt; 19, Edge 15 =&gt; 20, Edge 16 =&gt; 17, Edge 17 =&gt; 18, Edge 18 =&gt; 19, Edge 19 =&gt; 20], [10.0, 16.0, 9.0, 14.0, 17.0, 2.0, 16.0, 1.0, 8.0, 20.0, 3.0, 19.0, 10.0, 17.0, 18.0, 15.0, 10.0, 16.0, 9.0, 2.0, 7.0, 19.0, 1.0, 9.0, 3.0, 10.0, 12.0, 4.0, 4.0, 1.0, 15.0], [16.0 20.0 9.0 17.0 7.0 9.0 19.0 6.0 14.0 13.0 4.0 20.0 18.0 1.0 18.0 3.0 9.0 4.0 13.0 7.0; 12.0 15.0 1.0 18.0 16.0 11.0 1.0 9.0 15.0 7.0 9.0 8.0 19.0 20.0 2.0 17.0 17.0 9.0 20.0 7.0; 1.0 1.0 19.0 5.0 8.0 6.0 11.0 15.0 8.0 2.0 7.0 5.0 13.0 13.0 1.0 11.0 12.0 4.0 12.0 10.0; 19.0 10.0 12.0 1.0 14.0 19.0 1.0 19.0 14.0 2.0 12.0 13.0 9.0 3.0 9.0 5.0 7.0 20.0 6.0 12.0; 17.0 4.0 15.0 12.0 8.0 4.0 17.0 6.0 11.0 1.0 14.0 5.0 6.0 7.0 17.0 9.0 16.0 8.0 13.0 3.0; 2.0 11.0 15.0 12.0 18.0 3.0 16.0 3.0 4.0 18.0 14.0 8.0 13.0 13.0 10.0 6.0 6.0 8.0 6.0 9.0; 8.0 7.0 16.0 13.0 3.0 10.0 10.0 13.0 6.0 4.0 1.0 13.0 12.0 17.0 7.0 6.0 2.0 3.0 3.0 1.0; 16.0 15.0 8.0 13.0 19.0 20.0 19.0 1.0 15.0 2.0 20.0 15.0 7.0 20.0 19.0 18.0 1.0 20.0 20.0 1.0; 11.0 4.0 8.0 20.0 16.0 19.0 17.0 20.0 8.0 16.0 5.0 16.0 14.0 10.0 4.0 5.0 4.0 12.0 18.0 17.0; 20.0 16.0 17.0 5.0 2.0 11.0 17.0 11.0 16.0 2.0 7.0 11.0 19.0 19.0 11.0 6.0 16.0 16.0 1.0 12.0; 5.0 4.0 19.0 14.0 15.0 2.0 19.0 16.0 17.0 5.0 11.0 14.0 15.0 13.0 5.0 19.0 2.0 17.0 6.0 8.0; 15.0 5.0 3.0 15.0 9.0 15.0 10.0 16.0 10.0 7.0 15.0 10.0 8.0 14.0 17.0 1.0 12.0 9.0 13.0 11.0; 19.0 6.0 9.0 10.0 3.0 6.0 17.0 20.0 12.0 11.0 15.0 8.0 15.0 11.0 15.0 3.0 1.0 16.0 17.0 7.0; 10.0 20.0 7.0 20.0 15.0 1.0 19.0 6.0 12.0 12.0 7.0 18.0 19.0 20.0 4.0 20.0 3.0 18.0 1.0 9.0; 17.0 11.0 15.0 12.0 14.0 15.0 19.0 11.0 10.0 8.0 8.0 13.0 12.0 8.0 9.0 2.0 10.0 17.0 14.0 14.0; 13.0 4.0 1.0 11.0 6.0 20.0 10.0 17.0 15.0 9.0 3.0 11.0 3.0 12.0 20.0 5.0 1.0 3.0 1.0 12.0; 11.0 13.0 7.0 14.0 3.0 6.0 13.0 13.0 14.0 13.0 6.0 5.0 1.0 13.0 19.0 17.0 11.0 11.0 2.0 10.0; 13.0 6.0 18.0 19.0 6.0 4.0 11.0 10.0 17.0 9.0 10.0 12.0 10.0 14.0 6.0 14.0 19.0 19.0 8.0 15.0; 8.0 12.0 5.0 7.0 8.0 12.0 6.0 10.0 15.0 9.0 2.0 6.0 16.0 17.0 14.0 3.0 20.0 8.0 7.0 18.0; 15.0 1.0 10.0 18.0 16.0 5.0 1.0 18.0 11.0 16.0 9.0 14.0 9.0 8.0 11.0 8.0 12.0 12.0 19.0 20.0; 10.0 16.0 14.0 8.0 20.0 9.0 5.0 10.0 2.0 4.0 15.0 13.0 13.0 8.0 9.0 18.0 5.0 13.0 1.0 1.0; 17.0 13.0 2.0 10.0 4.0 15.0 11.0 3.0 9.0 15.0 9.0 5.0 12.0 9.0 16.0 10.0 17.0 2.0 15.0 1.0; 16.0 14.0 1.0 2.0 8.0 10.0 20.0 19.0 17.0 9.0 8.0 3.0 14.0 11.0 3.0 20.0 6.0 13.0 6.0 16.0; 19.0 17.0 3.0 1.0 15.0 4.0 12.0 12.0 8.0 20.0 13.0 18.0 2.0 16.0 14.0 15.0 8.0 4.0 3.0 18.0; 2.0 6.0 15.0 8.0 15.0 10.0 18.0 13.0 20.0 7.0 20.0 18.0 13.0 16.0 9.0 3.0 10.0 10.0 16.0 14.0; 9.0 8.0 13.0 17.0 13.0 11.0 6.0 10.0 17.0 18.0 13.0 20.0 11.0 16.0 14.0 9.0 16.0 20.0 3.0 7.0; 3.0 4.0 19.0 16.0 15.0 14.0 12.0 20.0 10.0 4.0 1.0 16.0 8.0 10.0 14.0 7.0 6.0 8.0 16.0 10.0; 4.0 11.0 8.0 6.0 16.0 7.0 17.0 5.0 12.0 7.0 1.0 8.0 6.0 10.0 5.0 20.0 2.0 13.0 19.0 10.0; 2.0 19.0 13.0 2.0 12.0 3.0 1.0 9.0 13.0 1.0 17.0 16.0 5.0 9.0 1.0 19.0 1.0 9.0 20.0 13.0; 19.0 4.0 14.0 2.0 19.0 14.0 19.0 11.0 12.0 11.0 20.0 1.0 4.0 1.0 13.0 20.0 19.0 15.0 12.0 16.0; 20.0 2.0 1.0 1.0 4.0 2.0 18.0 1.0 6.0 20.0 18.0 16.0 17.0 14.0 13.0 6.0 10.0 6.0 7.0 3.0]</code></pre><p>As presented in the problem statement, the MIP formulation of the minimum weight two-stage spanning tree problem has an exponential number of constraints. We cannot solve it directly using a MIP solver, but we can solve it with a subset of constraints and iteratively add the most violated one, up until all constraint are satisfied.</p><p>Finding the most violated constraint (for a given scenario <span>$s$</span>) is called the <strong>separation problem</strong>, and can be formulated as:</p><p class="math-container">\[\begin{aligned}
\min_Y\quad &amp; |Y| - 1 - \sum_{e\in E(Y)}(y_e + z_{es})\\
\text{s.t.}\quad &amp; \emptyset \subsetneq Y\subsetneq V
\end{aligned}\]</p><p>with <span>$y$</span>, <span>$z$</span> fixed and obtained by minimizing the problem restricted to a subset of constraints.</p><p>If the value of this problem is positive for all scenarios, then all constraints are satisfied and the optimal solution is found.</p><h3 id="MIP-separation-problem"><a class="docs-heading-anchor" href="#MIP-separation-problem">MIP separation problem</a><a id="MIP-separation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#MIP-separation-problem" title="Permalink"></a></h3><p>A straightforward way to solve the separation problem, is to formulate it as the following MILP:</p><p class="math-container">\[\begin{array}{rll}
\min\limits_{\alpha, \beta}\, &amp; \sum\limits_{v\in V}\alpha_v - 1 - \sum\limits_{e \in E} \beta_e (y_e + z_{es}) \\
\mathrm{s.t.}\, &amp; 2 \beta_{e} \leq \alpha_u + \alpha_v \qquad &amp; \forall e = (u,v)\in E \\
&amp; \sum\limits_{v\in V} \alpha_v \geq 1\\
&amp; \alpha, \beta \in \{0,1\}
\end{array}\]</p><p>This separation solver is implemented as <a href="../api/#TwoStageSpanningTree.MILP_separation_problem-Tuple{Any, Any}"><code>MILP_separation_problem</code></a> and can be given as input option to the <a href="../api/#TwoStageSpanningTree.cut_generation-Tuple{TwoStageSpanningTreeInstance}"><code>cut_generation</code></a> method:</p><pre><code class="language-julia hljs">mip_solution = cut_generation(instance; separation_problem=MILP_separation_problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TwoStageSpanningTreeSolution(Bool[0, 0, 0, 0, 0, 1, 0, 1, 0, 0  …  0, 1, 0, 1, 0, 0, 1, 1, 1, 0], Bool[0 0 … 1 1; 1 1 … 0 1; … ; 0 0 … 0 0; 0 1 … 1 1])</code></pre><p>The solution feasibility can be tested with the <a href="../api/#TwoStageSpanningTree.is_feasible-Tuple{TwoStageSpanningTreeSolution, TwoStageSpanningTreeInstance}"><code>is_feasible</code></a> method:</p><pre><code class="language-julia hljs">is_feasible(mip_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The objective value of a given solution can be computed using the <a href="../api/#TwoStageSpanningTree.solution_value-Tuple{TwoStageSpanningTreeSolution, TwoStageSpanningTreeInstance}"><code>solution_value</code></a> method:</p><pre><code class="language-julia hljs">solution_value(mip_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.3</code></pre><p>Solutions can be visualized scenario by scenario using the <a href="../api/#TwoStageSpanningTree.plot_scenario-Tuple{TwoStageSpanningTreeSolution, TwoStageSpanningTreeInstance, Any}"><code>plot_scenario</code></a> method:</p><pre><code class="language-julia hljs">plot_scenario(mip_solution, instance, 1; n, m)</code></pre><img src="bdcd2e6e.svg" alt="Example block output"/><h3 id="Cut-separation-problem"><a class="docs-heading-anchor" href="#Cut-separation-problem">Cut separation problem</a><a id="Cut-separation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Cut-separation-problem" title="Permalink"></a></h3><p>The separation problem can alternatively be formulated as a min-cut problem, which has better performance and scaling.</p><p>The separation problem</p><p class="math-container">\[\min  |Y| - 1 - \sum_{e \in E(Y)} (y_e + z_{es}) \quad \text{subject to} \quad \emptyset \subsetneq Y \subsetneq V\]</p><p>is equivalent to</p><p class="math-container">\[\min  |Y| + \sum_{e \notin E(Y)} (y_e + z_{es}) - |V| \quad \text{subject to} \quad \emptyset \subsetneq Y \subsetneq V.\]</p><p>Let us define the digraph <span>$\mathcal{D} = (\mathcal{V}, \mathcal{A})$</span> with vertex set <span>$\mathcal{V} = \{s,t\} \cup V \cup E$</span> and the following arcs.</p><table><tr><th style="text-align: right">Arc <span>$a$</span></th><th style="text-align: right">Capacity <span>$u_a$</span></th></tr><tr><td style="text-align: right"><span>$(s,e)$</span> for <span>$e \in E$</span></td><td style="text-align: right"><span>$y_e + z_{es}$</span></td></tr><tr><td style="text-align: right"><span>$(e,u)$</span> and <span>$(e,v)$</span> for <span>$e = (u,v) \in E$</span></td><td style="text-align: right"><span>$+\infty$</span></td></tr><tr><td style="text-align: right"><span>$(v,t)$</span> for <span>$v \in V$</span></td><td style="text-align: right"><span>$1$</span></td></tr></table><p>The separation problem is equivalent to finding a non-empty minimum-capacity <span>$s$</span>-<span>$t$</span> cut <span>$Y$</span> in <span>$\mathcal{D}$</span>. This can be done with the following MILP:</p><p class="math-container">\[\begin{array}{rll}
	\min \, &amp; \sum\limits_{a \in \mathcal{A}} u_a \beta_a \\
	\mathrm{s.t.} \, &amp; \alpha_s - \alpha_t \geq 1 \\
	&amp; \beta_a \geq \alpha_u - \alpha_v &amp; \text{ for all } a= (u,v) \in \mathcal{A} \\
	&amp; \sum\limits_{v \in V} \alpha_v \geq 1 \\
	&amp; \alpha, \beta \in \{0,1\}
\end{array}\]</p><p>This separation solving method is implemented by <a href="../api/#TwoStageSpanningTree.cut_separation_problem-Tuple{Any, Any}"><code>cut_separation_problem</code></a> and is also compatible with <a href="../api/#TwoStageSpanningTree.cut_generation-Tuple{TwoStageSpanningTreeInstance}"><code>cut_generation</code></a>.</p><p>We observe that using it is faster than the other method.</p><pre><code class="language-julia hljs">cut_solution = cut_generation(instance; separation_problem=cut_separation_problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TwoStageSpanningTreeSolution(Bool[0, 0, 0, 0, 0, 1, 0, 1, 0, 0  …  0, 1, 0, 1, 0, 0, 1, 1, 1, 0], Bool[0 0 … 1 1; 1 1 … 0 1; … ; 0 0 … 0 0; 0 1 … 1 1])</code></pre><pre><code class="language-julia hljs">@benchmark cut_generation(instance; separation_problem=MILP_separation_problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took <span class="sgr34">142.094 s</span> (0.09% GC) to evaluate,
 with a memory estimate of <span class="sgr33">1.98 GiB</span>, over <span class="sgr33">75237358</span> allocations.</code></pre><pre><code class="language-julia hljs">@benchmark cut_generation(instance; separation_problem=cut_separation_problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took <span class="sgr34">14.281 s</span> (0.79% GC) to evaluate,
 with a memory estimate of <span class="sgr33">1.35 GiB</span>, over <span class="sgr33">27728437</span> allocations.</code></pre><pre><code class="language-julia hljs">is_feasible(cut_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">solution_value(cut_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.3</code></pre><h2 id="2.-Column-generation"><a class="docs-heading-anchor" href="#2.-Column-generation">2. Column generation</a><a id="2.-Column-generation-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Column-generation" title="Permalink"></a></h2><p>Since minimum spanning tree can be solved efficiently, it is natural to perform a Dantzig-Wolfe reformulation of the problem previously introduced.</p><p>It leads to the following formulation.</p><p class="math-container">\[    \begin{array}{rll}
        \min\,&amp; \displaystyle\sum_{e \in E}c_e y_e +  \frac{1}{|S|}\sum_{e \in E}\sum_{s \in S}d_{es}z_{es}\\
        \mathrm{s.t.} \,&amp; y_e + z_{es} = \displaystyle\sum_{T \in \mathcal{T}\colon e \in T} \lambda_{T}^s &amp; \text{for all $e\in E$ and $s \in S$} \\
        &amp; \displaystyle\sum_{T \in \mathcal{T}} \lambda_{T}^s = 1 &amp; \text{for all }s \in S \\
        &amp; y,z,\lambda\in \{0,1\}
    \end{array}\]</p><p>The linear relaxation of this problem can be solved by column generation, and the problem itself can be solved using a Branch-and-Price. The linear relaxation is implemented by <a href="../api/#TwoStageSpanningTree.column_generation-Tuple{Any}"><code>column_generation</code></a>, and an heuristic using columns outputed by it is implemented by <code>column_heuristic</code>:</p><pre><code class="language-julia hljs">column_solution = column_heuristic(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TwoStageSpanningTreeSolution(Bool[0, 0, 0, 0, 0, 1, 0, 1, 0, 0  …  0, 1, 0, 1, 0, 0, 1, 1, 1, 0], Bool[0 0 … 1 1; 1 1 … 0 1; … ; 0 0 … 0 0; 0 1 … 1 1])</code></pre><pre><code class="language-julia hljs">@benchmark column_heuristic(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 2 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">3.177 s</span></span> … <span class="sgr35"> 3.181 s</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.07% … 0.06%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">3.179 s             </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.07%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">3.179 s</span></span> ± <span class="sgr32">2.778 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.07% ± 0.01%

  <span class="sgr34">█</span>                           <span class="sgr32"> </span>                          █  
  <span class="sgr34">█</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  3.18 s<span class="sgr90">        Histogram: frequency by time</span>        3.18 s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">65.07 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">370821</span>.</code></pre><pre><code class="language-julia hljs">is_feasible(column_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">solution_value(column_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.3</code></pre><h2 id="3.-Benders-decomposition"><a class="docs-heading-anchor" href="#3.-Benders-decomposition">3. Benders decomposition</a><a id="3.-Benders-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Benders-decomposition" title="Permalink"></a></h2><p>The integer optimal solution of the column generation formulation can be found using a Branch-and-price, quite heavy to implement. Another option is to apply a Benders decomposition to decouple the scenarios.</p><p>When first stage variables <span>$y$</span> are fixed, the subproblem for scenario <span>$s$</span> becomes:</p><p class="math-container">\[\begin{aligned}
\min_{z, \lambda}\quad &amp; \sum_{e\in E}d_{es} z_{es}\\
\text{s.t.}\quad &amp; z_{es} = \sum_{T\in \mathcal{T}\colon e\in T}\lambda_T^s - y_e &amp; \forall e \in E\\
&amp; \sum_{T\in\mathcal{T}}\lambda_T^s = 1\\
&amp; z, \lambda\geq 0
\end{aligned}\]</p><p>We can simplify further the formulation by removing variable <span>$z$</span>:</p><p class="math-container">\[\begin{aligned}
\min_{z, \lambda}\quad &amp; \sum_{T\in\mathcal{T}}\sum_{e\in T}d_{es}\lambda_T^s - cst(y_e) \\
\text{s.t.}\quad &amp; \sum_{T\in \mathcal{T}\colon e\in T}\lambda_T^s \geq y_e &amp; \forall e \in E\\
&amp; \sum_{T\in\mathcal{T}}\lambda_T^s = 1\\
&amp; z, \lambda\geq 0
\end{aligned}\]</p><p>We take its dual:</p><p class="math-container">\[\begin{aligned}
\max_{\mu, \nu}\quad &amp; \nu_s + \sum_{e\in E} y_e \mu_{es} - cst \\
\text{s.t.}\quad &amp; \sum_{e\in T} (d_{es} - \mu_{es}) - \nu_s \geq 0, &amp; \forall T\in\mathcal{T}\\
&amp; \mu\geq 0, \nu\in\mathbb{R}
\end{aligned}\]</p><p>This dual can be solved using constraint generation, with once again a usual minimum spanning tree separation problem that can be solved using Kruskal algorithm:</p><p class="math-container">\[\min \sum_{e\in T} (d_{es} - \mu_{es})\]</p><p>If the primal is feasible, we generate an optimality cut:</p><p class="math-container">\[\theta_s \geq \nu_s + \sum_{e\in E} \mu_{es}y_e - \sum_{e\in E} d_{es} y_e\]</p><p>When the primal is unfeasible, there is an unbounded ray for the dual, i.e. <span>$\mu, \nu$</span> such that <span>$\nu_s + \sum_e \mu_{es} y_e &gt; 0$</span> and <span>$-\nu_s - \sum_{e\in T}\mu_{es}$</span>. (<span>$\alpha \nu$</span> and <span>$\alpha\mu$</span> are also solutions for all <span>$\alpha &gt; 0$</span>). Such solution can be found by solving:</p><p class="math-container">\[\begin{aligned}
\max_{\mu, \nu}\quad &amp; \nu_s + \sum_{e\in E} \mu_{es} y_e \\
\text{s.t.}\quad &amp; -\nu_s - \sum_{e\in T}\mu_{es} \geq 0 &amp; \forall T\in \mathcal{T}\\
&amp; 0 \leq \mu_{es} \leq 1 &amp; \forall e\in E\\
&amp; \nu_s\leq 1
\end{aligned}\]</p><p>Let us denote <span>$\mathcal{F}$</span> the feasibility cuts and <span>$\mathcal{O}_s$</span> the optimality cuts set. We obtain the following Benders master problem:</p><p class="math-container">\[\begin{aligned}
\max_{y}\quad &amp; \sum_{e\in E} c_e y_e + \frac{1}{|S|}\sum_{s\in S}\theta_s \\
\text{s.t.}\quad &amp; \theta_s \geq \nu_s + \sum_{e\in E} \mu_{es} y_e - \sum_{e\in E} d_{es} y_e &amp; \forall s\in S,\, \forall (\nu, \mu) \in \mathcal{O}_s\\
&amp; \nu + \sum_{e\in E} \mu_e y_e &amp; \forall (\nu, \mu)\in \mathcal{F}\\
&amp; y\in\{0, 1\}
\end{aligned}\]</p><p>The <a href="../api/#TwoStageSpanningTree.benders_decomposition-Tuple{TwoStageSpanningTreeInstance}"><code>benders_decomposition</code></a> implements this method:</p><pre><code class="language-julia hljs">benders_solution = benders_decomposition(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TwoStageSpanningTreeSolution(Bool[0, 0, 0, 0, 0, 1, 0, 1, 0, 0  …  0, 1, 0, 1, 0, 0, 1, 1, 1, 0], Bool[0 0 … 1 1; 1 1 … 0 1; … ; 0 0 … 0 0; 0 1 … 1 1])</code></pre><pre><code class="language-julia hljs">@benchmark benders_decomposition(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 3 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.248 s</span></span> … <span class="sgr35"> 2.261 s</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>3.63% … 3.69%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.253 s             </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>3.68%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.254 s</span></span> ± <span class="sgr32">6.479 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.67% ± 0.03%

  <span class="sgr34">█</span>                      █  <span class="sgr32"> </span>                            █  
  <span class="sgr34">█</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.25 s<span class="sgr90">        Histogram: frequency by time</span>        2.26 s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">860.88 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">17250205</span>.</code></pre><pre><code class="language-julia hljs">is_feasible(benders_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">solution_value(benders_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.3</code></pre><h2 id="4.-Lagrangian-relaxation"><a class="docs-heading-anchor" href="#4.-Lagrangian-relaxation">4. Lagrangian relaxation</a><a id="4.-Lagrangian-relaxation-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Lagrangian-relaxation" title="Permalink"></a></h2><p>Let us introduce one copy of first stage variables <span>$y$</span> per scenario. An equivalent formulation of the problem is</p><p class="math-container">\[\begin{array}{ll}
\min\, &amp; \displaystyle \sum_{e\in E}c_e y_e + \sum_{e \in E} \sum_{s \in S}d_{es}z_{es} \\
\mathrm{s.t.}\, &amp; \mathbf{y}_s + \mathbf{z}_s \in \mathcal{P}, \quad\quad \text{for all $s$ in $S$}  \\
&amp; y_{es} = y_e, \quad \quad \quad \,\text{for all $e$ in $E$ and $s$ in $S$}
\end{array}\]</p><p>Let us relax (dualize) the constraint <span>$y_{es} = y_e$</span>. We denote by <span>$\theta_{es}$</span> the associated Lagrange multiplier.</p><p>The Lagrangian dual problem becomes</p><p class="math-container">\[\begin{array}{rlrlrl}
\max_{\theta}\mathcal{G}(\theta)= \min_{y}&amp; \sum_{e \in E}(c_e + \frac{1}{|S|}\sum_{s \in S} \theta_{es})y_e \\
&amp;+ \frac{1}{|S|}\sum_{s \in S}\min_{\mathbf{y}_s,\mathbf{z}_s} \sum_{e \in E}d_{es}z_{es} - \theta_{es}y_{es}\\
\mathrm{s.t.} &amp; 0 \leq \mathbf{y} \leq M\\
&amp; \mathbf{y}_s + \mathbf{z}_s \in \mathcal{P}, \quad\quad \text{for all $s$ in $S$}
\end{array}\]</p><p>where <span>$M$</span> is a large constant. In theory, we would take <span>$M=+\infty$</span>, but taking a finite <span>$M$</span> leads to more informative gradients.</p><p>We have</p><p class="math-container">\[(\nabla \mathcal{G}(\theta))_{es}= \frac{1}{|S|} (y_e - y_{es}).\]</p><p>Considering the sum on the second stage scenarios as an expectation, we can get stochastic gradients and maximize <span>$\mathcal{G}$</span> using gradient ascent.</p><p>Once a solution of the relaxed problem is found, we have one solution <span>$y_s$</span> per scenario <span>$s$</span>. We can then use an heuristic to reconstruct a good first stage decision <span>$y$</span>.</p><p>The <a href="../api/#TwoStageSpanningTree.lagrangian_relaxation-Tuple{TwoStageSpanningTreeInstance}"><code>lagrangian_relaxation</code></a> method implements this heuristic:</p><pre><code class="language-julia hljs">solution, (; ub_history, lb_history) = lagrangian_relaxation(instance; nb_epochs=25000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(TwoStageSpanningTreeSolution(Bool[0, 0, 0, 0, 0, 1, 0, 1, 0, 0  …  0, 1, 0, 1, 0, 0, 1, 1, 1, 0], Bool[0 0 … 1 1; 1 1 … 0 1; … ; 0 0 … 0 0; 0 1 … 1 1]), (lb = 83.0976138937488, ub = 83.3, best_theta = [-12.006932482972793 -15.007348088496224 … -13.006219386699618 -7.006453798809543; -12.006901067883822 -15.005898389939647 … -13.00760072106909 -7.007835739530329; … ; -0.9998971735509196 -0.9998971735509196 … -0.9998971735509196 -0.9998971735509196; -9.003327130863028 -2.0067862263899836 … -7.007335814637157 -3.0059434343710345], lb_history = [0.0, 0.006999998600000279, 0.020949986145160637, 0.03633246164080159, 0.05248061480149503, 0.06758024632766592, 0.08210482635979983, 0.09590500828604871, 0.11048415084952032, 0.12608030884224528  …  83.09411315910612, 83.09460627462344, 83.09496415021687, 83.09533038133962, 83.09559216959877, 83.0959608410161, 83.0965045532183, 83.09493249360916, 83.0976138937488, 83.09567396785975], ub_history = [202.0, 202.0, 202.0, 202.0, 202.0, 202.0, 202.0, 202.0, 202.0, 202.0  …  83.3, 83.3, 83.3, 83.3, 83.3, 83.3, 83.3, 83.3, 83.3, 83.3]))</code></pre><pre><code class="language-julia hljs">@benchmark lagrangian_relaxation(instance; nb_epochs=25000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 4 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.411 s</span></span> … <span class="sgr35"> 1.428 s</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>2.40% … 2.41%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.418 s             </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>2.41%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.419 s</span></span> ± <span class="sgr32">7.378 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>2.42% ± 0.02%

  █           <span class="sgr34">█</span>             <span class="sgr32"> </span>        █                   █  
  █▁▁▁▁▁▁▁▁▁▁▁<span class="sgr34">█</span>▁▁▁▁▁▁▁▁▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  1.41 s<span class="sgr90">        Histogram: frequency by time</span>        1.43 s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">2.70 GiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">10519518</span>.</code></pre><pre><code class="language-julia hljs">is_feasible(benders_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">solution_value(benders_solution, instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.3</code></pre><p>We can plot the evolution of both lower and upper bounds along iterations</p><pre><code class="language-julia hljs">using Plots
f = plot()
plot!(f, ub_history; label=&quot;Upper bound: lagrangian heuristic&quot;, color=:orange)
plot!(f, lb_history; label=&quot;Lower bound: lagrangian relaxation&quot;, color=:purple)
f</code></pre><img src="6fdbf141.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem_statement/">« Problem statement</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 13 February 2024 09:45">Tuesday 13 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
